{
  "db_name": "PostgreSQL",
  "query": "\n        WITH running_entities AS (\n            SELECT DISTINCT jobs.entity_id\n            FROM job_executions\n            JOIN jobs ON job_executions.id = jobs.id\n            WHERE job_executions.state = 'running'\n            AND jobs.entity_id IS NOT NULL\n        ),\n        pending_candidates AS (\n            SELECT\n                je.id,\n                je.execution_state_json AS data_json,\n                je.attempt_index,\n                je.execute_at,\n                COALESCE(jobs.entity_id, je.id) AS sequencing_key,\n                (running_entities.entity_id IS NOT NULL) AS is_blocked\n            FROM job_executions je\n            JOIN jobs ON je.id = jobs.id\n            LEFT JOIN running_entities ON jobs.entity_id = running_entities.entity_id\n            WHERE je.state = 'pending'\n        ),\n        min_wait AS (\n            SELECT MIN(GREATEST(execute_at, $2::timestamptz)) - $2::timestamptz AS wait_time\n            FROM pending_candidates\n        ),\n        ranked_candidates AS (\n            SELECT\n                id,\n                data_json,\n                attempt_index,\n                execute_at,\n                is_blocked,\n                ROW_NUMBER() OVER (\n                    PARTITION BY sequencing_key\n                    ORDER BY execute_at, id\n                ) AS seq\n            FROM pending_candidates\n            WHERE execute_at <= $2::timestamptz\n        ),\n        selected_jobs AS (\n            SELECT id, data_json, attempt_index\n            FROM ranked_candidates\n            WHERE seq = 1 AND NOT is_blocked\n            ORDER BY execute_at, id\n            LIMIT $1\n            FOR UPDATE\n        ),\n        updated AS (\n            UPDATE job_executions AS je\n            SET state = 'running', alive_at = $2, execute_at = NULL, poller_instance_id = $3\n            FROM selected_jobs\n            WHERE je.id = selected_jobs.id AND je.state = 'pending'\n            RETURNING je.id, selected_jobs.data_json, je.attempt_index\n        )\n        SELECT * FROM (\n            SELECT \n                u.id AS \"id?: JobId\",\n                u.data_json AS \"data_json?: JsonValue\",\n                u.attempt_index AS \"attempt_index?\",\n                NULL::INTERVAL AS \"max_wait?: PgInterval\"\n            FROM updated u\n            UNION ALL\n            SELECT \n                NULL::UUID AS \"id?: JobId\",\n                NULL::JSONB AS \"data_json?: JsonValue\",\n                NULL::INT AS \"attempt_index?\",\n                mw.wait_time AS \"max_wait?: PgInterval\"\n            FROM min_wait mw\n            WHERE NOT EXISTS (SELECT 1 FROM updated)\n        ) AS result\n        ",
  "describe": {
    "columns": [
      {
        "ordinal": 0,
        "name": "id?: JobId",
        "type_info": "Uuid"
      },
      {
        "ordinal": 1,
        "name": "data_json?: JsonValue",
        "type_info": "Jsonb"
      },
      {
        "ordinal": 2,
        "name": "attempt_index?",
        "type_info": "Int4"
      },
      {
        "ordinal": 3,
        "name": "max_wait?: PgInterval",
        "type_info": "Interval"
      }
    ],
    "parameters": {
      "Left": [
        "Int8",
        "Timestamptz",
        "Uuid"
      ]
    },
    "nullable": [
      null,
      null,
      null,
      null
    ]
  },
  "hash": "68ae7bb036fee7ace499bde8319e6d1640df6be78c36fd5ea4210be823887e70"
}
